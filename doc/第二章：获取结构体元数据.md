## 第二章：元数据获取

这一部分，我们就来使用上一章介绍的芝士获取结构体的元信息。

---

### 结构体成员名称获取

​	上一章我们提到，可以通过编译器内置的宏（`MSVC：__FUNCSIG__`、`clang、gcc：__PRETTY_FUNCTION__`）来获取成员变量名称，具体表现为：

```c++
// void __cdecl get_func_name_template<&p.m_name>(void)
```

定义一个示例用的结构体：`struct Person { int m_age; std::string m_name; };`	

那么，通过一定的字符串截取，我们就可以拿到一个结构体成员的名称：

```c++
template <auto val>
inline constexpr std::string_view get_member_type_name() {
#if defined(_MSC_VER)
    std::string_view funcName = __FUNCSIG__;
    size_t begin = funcName.rfind(".") + 1;
    size_t end = funcName.rfind(">(");
    return funcName.substr(begin, end - begin);
#endif
}
static Person p;
get_func_name_template<&p.m_name>();
// out: m_name
```

但是，对于一个用于存储网络请求的结构体来说，结构体成员的数量可能非常多，如果对于每一个都这样手动的去获取，和`REFLECTION(Person, m_name, m_age)`就没区别了，这时候上一章讲到的结构化绑定就派上用场了，能够想到：

```c++
int main () {
    static Person p;
    auto& [age, name] = p;
    get_member_type_name<&age>();
}
```

但是编译后会发现报错：`error C2672: “get_member_type_name”: 未找到匹配的重载函数`，这是因为`age` 是**局部结构化绑定引用**，`&age` 不是地址常量表达式。所以对于`&p`是可以的，但是`&age`不行。核心在于，我们需要告诉编译器，age是一个编译期常量，对于这个问题，解决方案如下：

```c++
inline constexpr auto get_tuple() {  	   			
    auto& [a, b] = p;			    
    return std::tie(a, b);						
}
std::cout << get_member_type_name<&std::get<1>(get_tuple())>() << std::endl;
// out: m_name
```

`get_tuple()`函数的返回值被修饰为`constexpr`表示这个函数可以在编译期被调用，而对于`tuple`，编译器在编译期会将其折叠为：`p.m_name`的引用，这时候再取地址就没有问题了。

不过现在我们的`Person`的全局成员`p`也需要使用者自己定义，同时`get_tuple`函数只能支持两个成员的函数，作为一个可用性强的库来说，这些都是不应该存在的。

---

#### 定义全局唯一对象

为了解决第一个问题，我们就需要针对不同的用户类型做统一处理，可以想到的是：

```c++
template <typename T>
struct Wrapper {
	inline static std::remove_cvref_t<T> value;
};
```

针对任意对象，定义一个全局存在的唯一实例，并用`Wrapper`匿名起来，这里就是一个静态反射的额外开销，只要做一次反射，该类型就会有且仅有一个唯一实例被创建在内存当中。



---

#### 结构体成员数量获取

对于第二个问题，我们可以通过打表来解决，通过定义宏来支持有更多的成员参数的结构体：

```c++
template <AggregateType T, size_t N>
struct get_member_references_tuple {
	// get tuple by type
	inline static constexpr auto get_tuple() {
		if constexpr (N <= 0) {
			static_assert(N <= 0, "Too few structural member parameters (size <= 0)");
		} else {
			static_assert(N > 5, "Too many structural member parameters (size >= 5)");
		}
	}
}

#define GET_MEMBER_TUPLE_HELPER(n, ...) 						\  // 对结构体的偏特化
template <AggregateType T>   									\
struct get_member_references_tuple<T, n> { 						\
	inline static constexpr auto get_tuple() {  	   			\
		auto& [__VA_ARGS__] = Wrapper<T>::value;			    \
		return std::tie(__VA_ARGS__);							\
	}   													\
}

GET_MEMBER_TUPLE_HELPER(1, a)
GET_MEMBER_TUPLE_HELPER(2, a, b)
GET_MEMBER_TUPLE_HELPER(3, a, b, c)
...
```

这样理论上来说，我们就可以针对任意数量的结构体进行解析了

但是我们如何知道一个结构体的成员数量从而精确匹配偏特化呢？

这里贴一些[获取编译期成员数量](https://lumia431.github.io/2025/05/09/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84%E5%88%9D%E6%8E%A2%EF%BC%81%EF%BC%81/)的文章。

贴一个拓展支持 [获取 包含原生数组成员的 结构体成员数量](https://zhuanlan.zhihu.com/p/674157958) 的文章

这里再贴一个大佬的[编译期反射](https://netcan.github.io/2020/08/01/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0C-%E7%BC%96%E8%AF%91%E6%9C%9F%E9%9D%99%E6%80%81%E5%8F%8D%E5%B0%84/)文章。

```c++
#define GET_MEMBER_TUPLE_HELPER(n, ...) 						\
template <AggregateType T>   									\
struct get_member_references_tuple<T, n> { 						\
	inline static constexpr auto get_tuple() {  	   			\
		auto& [__VA_ARGS__] = Wrapper<T>::value;			    \
		return std::tie(__VA_ARGS__);							\
	}   														\
};															

#include "reflection_get_member_tuple_helper.hpp"

template <AggregateType T>
using member_array = std::array<std::string_view, members_count_v<remove_cvref_t<T>>>;

// get members tuple
template  <AggregateType T>
inline constexpr auto struct_members_to_tuple() {
	return get_member_references_tuple<T, members_count_v<T>>::get_tuple();
}

// get members array
template <AggregateType T>
inline consteval member_array<T> struct_members_to_array() {
	using U = remove_cvref_t<T>;
	constexpr auto tuple = struct_members_to_tuple<U>();
	return [&] <size_t... Is>(std::index_sequence<Is...>) {
        return member_array<T>{get_member_name<&std::get<Is>(tuple)>()...};
		// return member_array{get_member_name_v<Is, tuple>()...};
    }(std::make_index_sequence<members_count_v<U>>());
}
```



---

### 结构体成员引用获取



最终，我们就能够获得结构体成员名称的`array`了，再进一步拓展上面代码，在我们原本的宏定义基础上添加引用的获取（因为引用也要用到结构化绑定，也要用到打表的结构体）：

```c++
#define GET_MEMBER_TUPLE_HELPER(n, ...) 						\
template <AggregateType T>   									\
struct get_member_references_tuple<T, n> { 						\
	inline static constexpr auto get_tuple() {  	   			\
		auto& [__VA_ARGS__] = Wrapper<T>::value;			    \
		return std::tie(__VA_ARGS__);							\
	}   														\
	inline static decltype(auto) get_reference_value(T&& t) {   \  
		auto&& [__VA_ARGS__] = std::forward<T>(t);				\
		return std::tie(__VA_ARGS__);							\
	}															\
};	
```

使用`get_reference_value`  对运行时对象进行结构化绑定，这里不能使用`constexpr`关键字。

获取指定索引的运行时成员引用：

```c++
// get members reference
template <size_t Index, typename T>
inline decltype(auto) struct_member_reference(T&& t) {
	using U = remove_cvref_t<T>;
    constexpr size_t count = members_count_v<U>;
	static_assert(Index < count, "Index out of range");
	return std::get<Index>(get_member_references_tuple<T, count>::get_reference_value(std::forward<T>(t)));
}
```

到这里我们就能基础的获得一个结构体的元信息了，这些信息足够我们实现一个基础的序列化功能了。

---

## 本章总结

本章的代码见：https://github.com/SSmallOrange/TinyReflection/blob/master/tinyrefl/utils/reflection_get_tuple.hpp

本章相关测试代码：

https://github.com/SSmallOrange/TinyReflection/blob/master/test/test_get_member_string_and_type_string.cpp

https://github.com/SSmallOrange/TinyReflection/blob/master/test/test_get_member_value.cpp

下一章我们将基于上述功能实现基础的Json序列化能力。
